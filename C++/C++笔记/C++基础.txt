1、int *a = new int[10]和 int *a = new int(10)有什么区别?
前者是使a指向一个数组，这个数组的每个元素都是int型，值没有初始化
后者是使a指向一个int型对象，这个对象的值为10
2、使用string必须加上using namespace std;
3、 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
    如果函数声明有默认值，函数实现的时候就不能有默认参数
4、类的头文件可以忽略具体的形参，只需给出参数类型，且可以带有默认值

5、函数重载：两个函数：一个带两个形参（其中一个带有默认值），一个带一个同类型的参数，，调用时指出传入一个参数，会产生歧义
6、构造函数，没有返回值也不写void
函数名称与类名相同
构造函数可以有参数，因此可以发生重载
析构函数，没有返回值也不写void
函数名称与类名相同,在名称前加上符号 ~
析构函数不可以有参数，因此不可以发生重载

7、C++中拷贝构造函数调用时机通常有三种情况:（普通变量的浅拷贝不影响，指针的浅拷贝地址会相同）
-使用一个已经创建完毕的对象来初始化一个新对象
-值传递的方式给函数参数传值
-以值方式返回局部对象

Person man(100); 
Person newman2 = man; //浅拷贝构造=Person newman2(man)

实例化类的指针对象：class* a = new class;//实例化类class的对象a
			delete a；

构造函数调用规则如下：

如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造

如果用户定义拷贝构造函数，c++不会再提供其他构造函数

浅拷贝：简单的赋值拷贝操作
深拷贝：在堆区重新申请空间，进行拷贝操作
①两个（或两个以上）指针指向同一块空间，这个内存就会被释放多次；
②另一方面，当两个指针指向同一块空间时，一旦一个指针修改了这块空间的值，另一个指针指向的空间的值也会被修改。
解决：自己写拷贝构造函数，在里面new开辟新空间，对应的要在析构函数delete

初始化列表:
构造函数()：属性1(值1),属性2（值2）...
{

 }

//当类中成员是其他类对象时，我们称该成员为 对象成员
//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
//析构顺序与构造相反

静态成员：
①静态成员就是在成员变量和成员函数前加上关键字static
该类的所有对象共享同一份数据（某一个对象将该静态变量改变则其他对象访问时的值也会变），类内声明，类外初始化（私有静态变量仍然要在类外初始化，只是无法直接访问），注意类外初始化不加static，但要加上类名
访问方式：
通过对象  或者 直接Person::age
②静态成员函数只能访问静态成员变量
访问方式：通过对象  或者 类名
注：（私有静态变量/函数仍然无法直接访问），只有非静态成员变量占用对象空间，有各自的内存，其余（静态函数/变量，非静态函数）都是共享一个实例，公用一个代码

this作用：
	Person(int age)
	{
		//1、当形参和成员变量同名时，可用this指针来区分
		this->age = age;
	}

	Person& PersonAddPerson(Person p)
	{
		this->age += p.age;
		//2、返回对象本身
		return *this;
	}

p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
若不采用返回对象本身：
void PersonAddPerson(Person p)
	{
		this->age += p.age;
	}
只能调用一次p2.PersonAddPerson(p1);

空指针也可以调用成员函数
	Person * p = NULL;
	p->ShowClassName(); //空指针，可以调用成员函数
因此要在某些函数里判断this == NULL

类的：
常函数：函数名后+const
	void ShowPerson() const {}
常对象：const Person p1;
常对象/函数内只能修改关键字mutable修饰的变量
const对象只能调用const函数

【友元】
在类的外部，如通过类的对象，则只能访问 public 属性的成员，不能访问protected、private属性的成员。

public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；
protected：可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问；
private：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象、访问。

友元函数只需要用friend声明，定义时不加friend

友元的三种实现：
①全局函数做友元：在类三个关键词外，全局函数加friend声明为全局友元，可访问私有
②类做友元：在三个关键词外，friend class xx;声明xx类为友元类，友元类可以调用自己类的函数进行访问其私有
③成员函数做友元：在三个关键词外，将其他类的成员函数声明为友元friend void goodGay::visit();

运算符重载：
类型 operator符号(参数列表)
{
	
}

继承：
class xx ：public xxx
{
}
//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数，
如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域（同名变量也一样）
如：子类对象调用子类同名函数s.fun()、子类对象调用父类s.xxx::fun()

同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）

C++允许一个类继承多个类：
语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2...
多继承可能会引发父类中有同名成员出现，需要加作用域区分

菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
利用虚继承可以解决菱形继承问题：
class Animal
{
};

//继承前加virtual关键字后，变为虚继承
//此时公共的父类Animal称为虚基类
class Sheep : virtual public Animal 
{

};
class Tuo : virtual public Animal
{

};
class SheepTuo : public Sheep, public Tuo 
{

};

多态分为两类:

静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名
动态多态: 派生类和虚函数实现运行时多态
静态多态和动态多态区别：

静态多态的函数地址早绑定 - 编译阶段确定函数地址
动态多态的函数地址晚绑定 - 运行阶段确定函数地址

//多态满足条件： 
//1、有继承关系
//2、子类重写父类中的虚函数（父类中的该函数要使用virtual声明）
（重写：函数返回值类型 函数名 参数列表 完全一致称为重写）
//多态的使用方法：
//父类指针或引用指向子类对象（注意采用虚析构函数，释放子类的堆空间）

【纯虚函数】
在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容
因此可以将虚函数改为纯虚函数
纯虚函数语法：virtual 返回值类型 函数名(参数列表）= 0 ;
当类中有了纯虚函数，这个类也称为抽象类
抽象类特点：
无法实例化对象
子类必须重写抽象类中的纯虚函数，否则也属于抽象类

c++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此，在子类从新声明该虚函数时，可以加，也可以不加。

【虚析构函数】
虚析构函数就是用来解决通过父类指针释放子类对象
如果子类中没有堆区数据，可以不写为虚析构或纯虚析构

解决方式：将父类中的析构函数改为虚析构或者纯虚析构
virtual ~类名(){}
virtual ~类名() = 0;

虚析构和纯虚析构共性：
可以解决父类指针释放子类对象
都需要有具体的函数实现

虚析构和纯虚析构区别：
如果是纯虚析构，该类属于抽象类，无法实例化对象

【类型转换】https://www.cnblogs.com/evenleee/p/10382335.html
去const属性用const_cast：

基本类型转换用static_cast：


多态类之间的类型转换用dynamic_cast：


不同类型的指针类型转换用reinterpret_cast：














